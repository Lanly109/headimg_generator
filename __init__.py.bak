import re
import shlex
import sys
from base64 import b64encode
from io import BytesIO
from typing import List, Tuple
from hoshino import HoshinoBot, Service, priv
from hoshino.typing import CQEvent, MessageSegment
from .data_source import commands, make_image, SPECIAL_DETAIL_HELP
from .download import DownloadError, ResourceError
from .models import UserInfo
from .utils import help_image

sv_help = """
[头像表情包] 发送全部功能帮助
"""

cmd_prefix = "##"

sv = Service(
    name="头像表情包",
    use_priv=priv.NORMAL,  # 使用权限
    manage_priv=priv.ADMIN,  # 管理权限
    visible=True,  # False隐藏
    enable_on_default=True,  # 是否默认启用
    bundle='娱乐',  # 属于哪一类
    help_=sv_help  # 帮助文本
)


@sv.on_fullmatch(["帮助头像表情包"])
async def bangzhu(bot, ev):
    await bot.send(ev, sv_help, at_sender=True)


def bytesio2b64(im: BytesIO) -> str:
    im = im.getvalue()
    return f"base64://{b64encode(im).decode()}"


@sv.on_fullmatch("头像表情包")
async def bangzhu(bot: HoshinoBot, ev: CQEvent):
    im = await help_image(commands)
    await bot.send(ev, MessageSegment.image(bytesio2b64(im)))


def is_qq(msg: str):
    return msg.isdigit() and 11 >= len(msg) >= 5


async def get_user_info(bot: HoshinoBot, user: UserInfo):
    if not user.qq:
        return

    if user.group:
        info = await bot.get_group_member_info(
            group_id=int(user.group), user_id=int(user.qq)
        )
        user.name = info.get("card", "") or info.get("nickname", "")
        user.gender = info.get("sex", "")
    else:
        info = await bot.get_stranger_info(user_id=int(user.qq))
        user.name = info.get("nickname", "")
        user.gender = info.get("sex", "")


async def handle(ev: CQEvent, prefix: str = "") -> [Tuple[List[UserInfo], List[str]], Tuple[None, None]]:
    users: List[UserInfo] = []
    args: List[str] = []
    msg = ev.message
    # 回复前置处理
    if msg[0].type == "reply":
        # 当回复目标是自己时，去除隐式at自己
        if msg[0].data["qq"] == str(ev.user_id):
            msg.pop(1)
        # 因为回复别人会默认多加一个at，需要跳过回复附带的显式at
        elif len(msg) > 3:
            temp_msg = [msg[0]] + [each for each in msg[3:]]
            at_sb = MessageSegment.at(msg[0].data["qq"])
            if temp_msg[1] == at_sb:
                temp_msg.pop(1)
            msg = temp_msg
        # 手机版可以去掉显式at，因此直接去除隐式at即可
        else:
            at_sb = MessageSegment.at(msg[0].data["qq"])
            if msg[1] == at_sb:
                msg.pop(1)

    has_non_reply_cmd = False
    # 当回复中存在指令时同样会被handler捕获，因此需要检查是回复的信息存在指令还是文本本身存在指令
    for each in msg:
        match = re.search(rf"(?:pp)?{cmd_prefix}([\w@]+)(?:\s.+)?", each.data["text"])
        if match and not each.type == "reply":
            has_non_reply_cmd = True
            break

    if not has_non_reply_cmd:
        return None, None

    for msg_seg in msg:
        if msg_seg.type == "at":
            users.append(UserInfo(qq=msg_seg.data["qq"], group=str(ev.group_id), bot_qq=str(ev.self_id)))
        elif msg_seg.type == "image":
            users.append(UserInfo(img_url=msg_seg.data["url"], bot_qq=str(ev.self_id)))
        elif msg_seg.type == "reply":
            msg_id = msg_seg.data["id"]
            source_msg = await sv.bot.get_msg(message_id=int(msg_id))
            source_msg = source_msg["message"]
            if source_msg.startswith("[CQ:image,"):
                url = re.search(r"url=(.+)", str(source_msg))
                if not url:
                    continue
                users.append(UserInfo(img_url=url.group(1), bot_qq=str(ev.self_id)))
            else:
                qq = msg_seg.data["qq"]
                users.append(UserInfo(qq=qq, group=str(ev.group_id), bot_qq=str(ev.self_id)))
        elif msg_seg.type == "text":
            raw_text = re.sub(prefix, "", str(msg_seg)).strip()
            try:
                texts = shlex.split(raw_text)
            except Exception as e:
                print(e)
                texts = raw_text.split()
            for text in texts:
                if is_qq(text):
                    users.append(UserInfo(qq=text, bot_qq=str(ev.self_id)))
                elif text == "自己":
                    users.append(UserInfo(qq=str(ev.user_id), group=str(ev.group_id), bot_qq=str(ev.self_id)))
                else:
                    text = text.strip()
                    if text:
                        args.append(text)
    if not users:
        users.append(UserInfo(qq=str(ev.self_id), group=str(ev.group_id), bot_qq=str(ev.self_id)))
    args.pop(0)
    return users, args


# noinspection PyUnboundLocalVariable
@sv.on_message()
async def gen_image(bot: HoshinoBot, ev: CQEvent):
    match = re.search(rf"(?:pp)?{cmd_prefix}([\w@]+)(?:\s.+)?", str(ev.message))
    if match:
        hit: str = match.group(1)
        for com in commands:
            for kw in com.keywords:
                if hit == kw:
                    # noinspection PyUnresolvedReferences
                    # noinspection PyProtectedMember
                    sv.logger.info(
                        f"Message {ev.message_id} triggered {sys._getframe().f_code.co_name}_{kw}"
                    )
                    users, args = await handle(ev, f"/{hit}")
                    if users is None and args is None:
                        return
                    sender = UserInfo(qq=str(ev.user_id), bot_qq=str(ev.self_id))
                    await get_user_info(bot, sender)
                    for user in users:
                        await get_user_info(bot, user)
                    try:
                        im = await make_image(com, sender, users, args=args)
                    except DownloadError:
                        await bot.finish(ev, "图片下载出错，请稍后再试")
                    except ResourceError:
                        await bot.finish(ev, "资源下载出错，请稍后再试")
                    except ValueError as e:
                        await bot.send(ev, f"{e}")
                        return
                    except Exception as e:
                        sv.logger.warning(f"{e}")
                        await bot.finish(ev, "出错了，请稍后再试")
                    if isinstance(im, str):
                        im = MessageSegment.text(im)
                    else:
                        im = MessageSegment.image(bytesio2b64(im))
                    await bot.send(ev, im)
    return
